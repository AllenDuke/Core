# 扩展算法
## 模拟退火算法 随机算法
退火，即物体降温的过程。Metropolis准则，粒子在温度T时，出现能量差为ΔE的降温的概率为P(ΔE)=exp(ΔE/(kT))，其中E为温度T时的内能，
ΔE为其改变量，k为Boltzmann常数。温度越高，出现一次能量差为dE的降温的概率就越大；温度越低，则出现概率就越小。
又由于ΔE总是小于0（否则就不叫退火了），因此ΔE/kT < 0 ，所以P(ΔE)的函数取值范围是(0,1) 。

当新解比当前解要优时，总是接受；当新界比当前解要差时，以一定的概率接受差解，以此来跳出局部最优，最终概率性地取到全局最优。

解01背包（最终全局最优解的取得与参数的设置有关，而且总是难以取得，要注意随机函数的使用），参数设置：
1. 初始温度，终止温度。
2. 退火率（如0.95，温度每次缩小为原来的0.95，随着温度的下降，差解的接受概率也会降低）。
3. 概率选择上限次数，即对每一个E，ΔE的个数。
## 隐马尔可夫模型 图像识别
提取图像特征点，根据图像当前的特征向量去给出下一个可能出现的向量（或者给出某个向量出现的概率）。
## 素数
将一个数拆分成最多的素数，例如8->2,2,2,2 9->2,2,2,3，即拆分成最多的2和3，f(8)=4, f(9)=4，f(n)=n>>1;
## 输出1000以内的素数
### 埃氏筛法。
建立1-1000的bool数组，全部置为true，从2开始，然后将所有2的倍数全部置为false，到下一个置为true的位置n，然后将n的倍数全部置为false，
直到遍历结束，输出所有置为true的位置编号（该方法速度最快）。
## 微信红包分配算法
红包功能的设计实现是一个很有趣的话题，主要的功能是P个人抢总金额M的N个红包，满足先抢的N个人能抢到红包。只要保证Ni抢到的金额
区间在[0.01,2倍剩余金额平均值）就能ac。
## Arrays.sort
依据数组里的元素特征，选择适合的算法进行排序。有插入排序和双数插入排序，有快排和双轴快排，有归并。
### 双轴快排
思想同快排，但选定两个基准p1, p2，将待排数组分为3段。<p1, p1<=&&<=p2, >p2。  
##  限流算法 100/s | 100/min
### 计数器法，固定时间间隔，不严格要求
System.currentTimeMillis()获取到毫秒时间戳，/1000可得以s为单位的时间戳，/(60*1000)可得以min为单位的时间戳。
将某一批次的开始时间和剩余次数存到redis，再加上过期时间(主要用来清除)，之后的每一个请求，判断是否位于同一批次(判断key是否存在)，如果是，减少剩余次数，若剩余次数为0，
拒绝访问。如果不是同一批次，当前成为新一批次的开始(上一批次在redis中的信息，由于有过期时间，redis自会处理)。

弊端：在跨单位的两端，比如0.9s和1.1s连续的访问而造成服务超限，这是由于限流算法不是严格要求1000ms间隔造成的。
### 计数器法，严格要求时间间隔
解决如上弊端。

同样的，我们将以批次来作为考虑，System.currentTimeMillis()获取到毫秒时间戳，将某一批次的开始时间和剩余次数存到redis某个固定key中，
比如key为lock，使用hash结构，有两个field，分别为：begin, rest。再加上过期时间(主要用来清除)，之后的每一个请求，计算它与begin的间隔，
如果已经>1000，那么当前成为begin, rest更新为999。如果<=1000，如果rest==0，拒绝访问，否则rest--。
### 令牌桶算法
每秒生成100个令牌，存放到令牌桶里。
### 漏桶算法
## 接口的幂等性设计
使用token机制实现接口幂等性,通用性强的实现方法：
1. 生成全局唯一的token,token放到redis或jvm内存,token会在页面跳转时获取.存放到pageScope中,支付请求提交先获取token。
2. 提交后后台校验token，执行提交逻辑,提交成功同时删除token，生成新的token更新redis ,这样当第一次提交后token更新了,
页面再次提交携带的token是已删除的token后台验证会失败不让提交。
## 死锁检测算法
资源->持有线程，线程->请求资源，深度遍历，发现环则死锁。
## 组合数计算 C(m,n) m个当中挑n个
C(m,n)=C(m,m-n)=m!/(n! * (m-n)!)，即 m的全排列/(n的全排列*(m-n)的全排列)
## O(n)从无序数组中找第K
n+n/2+n/4+n/8+...+1=2n-1。
要点：等比数列求和，项数：log(2,n);
