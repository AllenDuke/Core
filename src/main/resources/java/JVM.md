# JVM
主要目标hotspot
## 运行时数据区
1. 堆（新生代，老年代，常量池也放在堆中，Class对象存在常量池中，static变量存在于Class对象尾部）。
2. 元空间（运行时常量池存放class文件信息，字节码，放在直接内存中，比以前放在堆内存中要灵活，可以加载更多的class文件）。
   * 元空间的内存管理
     - 在metaspace中，类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在Metaspace中的类元数据也是存活的，
     不能被回收。
     - 每个加载器有单独的存储空间，类型不同，分配的空间也不同。（当加载器过多而每个加载器只加载少量的类时，会造成内存浪费和碎片化，
     容易触发fullGC而且难以回收）
     - 省掉了GC扫描及压缩的时间。
     - 当GC发现某个类加载器不再存活了，会把对应的空间整个回收。（发生于FullGC）
3. 虚拟机栈（局部变量表，操作数栈，动态链接，方法出口）。一个方法对应一个栈帧。
4. 本地方法栈。
5. 程序计数器。唯一不会OOM。
## 基本数据类型
boolean在《Java虚拟机规范》给出了4个字节(当作int处理，hotspot中占1字节,当作byte处理)，
和boolean数组每个元素1个字节(当作byte处理)的定义。

另外，在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，
其他基本类型以及引用类型的值均占用一个数组单元。
也就是说，boolean、byte、char、short 这四种类型，在栈上占用的空间和 int 是一样的，和引用类型也是一样的。因此，
在 32 位的 HotSpot 中，这些类型在栈上将占用 4 个字节；而在 64 位的 HotSpot 中，他们将占 8 个字节。
当然，这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。
## SafePoint与SafeRegion(GC时，线程不能随意暂停)
SafePoint一般出现在以下位置：
1. 循环体的结尾
2. 方法返回前
3. 调用方法的call之后
4. 抛出异常的位置
这些位置保证线程不会长时间运行而无法到达SafePoint，避免其他线程都停顿等待本线程。

SafePoint无法解决线程未达到SafePoint并处于休眠或等待状态的情况，此时引入SafeRegion的概念。
SafeRegion是代码中的一块区域或线程的状态，在SafeRegion中，线程执行与否不会影响对象引用的状态(如Thred.sleep)。
线程进入SafeRegion会给自己加标记，告诉虚拟机可以进行GC；线程准备离开SafeRegion前会询问虚拟机GC是否完成。
## 指针压缩
在64位机器上当分片的jvm内存小于32G时，JVM默认开启指针压缩，超过32GB会关闭指针压缩。
32bit可以寻找到2的35次方，是因为进行了8字节的对齐，使得对象的起始地址的低3位为0，所以可以利用这特点，在解压缩的时候，左移3位，再加上偏移量。

## cpu负载过高问题定位
1. top。找出负载高的JVM进程。
2. top -Hp <pid>。找出该进程中负载高的线程。
3. printf '%x\n' <thread-id>。将线程id转换为16进制<thread-id-hex>。
4. jstack <pid> | grep -A12 <thread-id-hex>。定位问题代码。

## final
### 修饰类
表示该类不可继承
### 修饰方法
表示该方法不可被子类重写，属于编译时绑定，使用invokeSpecial指令，似乎是比invokeVirtual更快，好像private方法，默认标识为final。
当方法长度短时，编译器可能会将方法内联到调用处。
### 修饰类变量
static final必须初始化，手动设定初始值。属于编译时常量，调用时不会加载该类。
### 修饰成员变量
构造器中初始化，否则就会报编译错误，且this不应在构造方法中逸出。

## 类加载而造成的死锁

# 关于实现无gc的jvm的方案
在c++中，当出现==null等null的赋值指令时确定性析构。循环引用问题，可结合根可达分析算法，或者学习rust，使用弱引用。
用伙伴系统做内存的分配与回收，这是离散的，好处是没有像此前那样复制来复制去，加上线程本地缓冲区，依旧适用指针碰撞。
# 关于实现支持协程的jvm的方案
