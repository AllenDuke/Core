# 当我们在谈论分布式的时候，我们到底在谈论些什么
## 什么是分布式
分布式可以这样理解，就是一种操作，需要经过一系列计算机才能完成。而这些计算机是通过网络进行通信的，而网络则是具有一定延迟的，甚至是不可信的。

而为什么需要多台计算机呢？自然是单台计算的资源并不能完成“计算”（广义）。纵深发展的单体大型机当然也能解决问题，但是不足够“弹性”，例如，一些秒杀活动等
需要动态扩张/减少资源的，大型机难以满足“刚刚好”，少了不足，多了浪费。

所以，换个思路横向拓展，通过多个小型机和网络来完成计算，小型机则可以极大地接近“刚刚好”，减少浪费。当然这也带来了额外的性能和出错风险。
比如网络通信的速度越不如本地通信的速度，同时小型机组成的网络中，任一节点出错都可能导致计算失败，而随着节点数量的增加，这种出错的风险越大。

因此，正是在这样的背景下，我们需要一系列的算法和工程实现来构建一个可靠、可用的分布式系统，使得这些节点正确地完成计算。

## 分布式理论
那么分布式系统，面临或者说需要解决哪些问题呢？一般来说，相对于单体架构，分布式的问题可以认为主要是网络（可信情况下）带来的延迟。
如A->B，A往B发送消息后，等待B的响应。消息在网络中传输需要一定的时间，也可能丢失（TCP不会），消息到达B后，B开始处理，而在B处理过程中，
B可能会发生宕机，导致B难以在可见时间限度内响应A。
对于A来说，A并不知道消息是否到达了B或者B对消息的处理情况，除非A收到了B的响应。
但正如上面所述，A可能永远也得不到响应。那么，在A得到响应之前， AB所组成的系统，该如何演进？

如果AB是一个无状态的系统，比如对外提供的只是一些计算服务（如加法，乘法），那么就直接让客户端等待或者返回超时就好了。
但是，如果AB是一个有状态的系统，如AB是一个存储系统，我们需要仔细考虑好A，B，AB整体的状态演进，否则很容易就会导致数据不一致，客户端拿到不一致
的数据，可能会引发更大的灾难。

以下将默认AB为有状态的分布式存储系统（主备，集群）。
### CAP问题
C：一致性，A：可用性，P：分区容错性。

在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操
作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的
数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发
生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。

对于一些要求性能而不要求强一致的，可以用AP，比如，微博，qps高，要求响应快速，使用旧版本提供服务也没什么大影响，这样可以用AP类型的redis做缓存。

AP容易做到的，读即快照读，数据同步保证最终一致性。

现在我们来看看如何实现C(强一致/线性一致)P。
## 一致性
### 顺序一致
### 线性一致
明显地，如果数据只有一份，那就是单机了（参加redis的集群模式，或者其他分片路由存储系统）。但为了避免单点故障，一般都会要求数据有多个备份。
在这种情况下，每个节点都需要进行数据更新操作，如果这些操作不在同一个同步区域内进行，那么节点的状态就肯定无法**同时**达到一致。

同步区域的创建至少要求存在一个原子的、互斥的操作才能实现。可以参考单体机中的同步区域创建，
即CPU的#LOCK指令，MESI协议，总线锁定等。在分布式环境中，我们不能引入一个单独的**锁节点**，但这背离了初衷。
所以，我们需要在所有节点发起锁定，只有当所有节点（经过下面的分析会知道，其实在多数派就可以了，因为不存在两个多数派）都成功锁定时，
整体才实现了互斥，同步区域才创建完成，才可以安全地在区域内进行状态切换，切换完成后，再全部解锁。

所谓“锁定”，其实也是一种状态切换，可以和数据的更新合并在一起，即“更新”，“可读”。

我们的目的是使得分布式系统能向外提供一致的读写服务，那么在不要求系统内部总是保持一致的条件下，是否可以达到这样的目的呢？
现在每个节点的状态机是这样的：旧->新，每个节点无法

也就是来说，开始->A更新且通知B更新->B更新且回复A->A可读且通知B可读--x-->B可读->结束。
在x阶段，B接收到客户端的读请求时，客户端等待，或者B主动向A询问是否可读（此时A知道B已更新，A如果已经更新，则A标记自己可读，且回复B可读）。

用博弈论来看，当”更新“成为AB的二阶知识，即AB相互知道对方已经更新，AB才可以安全地进入一致性可读状态。

### 冲突与共识
如上是可以实现一致性，但不能满足P。比如有5个节点，划分成两个分区，节点数量分别是2和3，分区之间不能通信。

从分治的角度来看，产生分区的时候，每个分区是可以保持一致性的，但如果每个分区都提供服务的话，
那么问题就变成了跨分区（跨应用，不进行状态通信）的分布式事务。由于不进行状态通信，我们无法建立一个全局的同步区域。

~~正如上面的线性一致所述的，只有AB相互知道对方已经更新，AB才可以安全地进入一致性可读状态。因此，各分区组成的整体是不能达到线性一致的。~~
_除非有个中间服务能和他们通信（部分分区），转达他们的信息。比如，ABC中，AB不能通信，但AC可以通信，BC可以通信。其实网络还是算连通的。_
理论上，这样还是可以完成分布式事务，但会有很多的通信开销，同时，更常见的是**完全分区**，或者说C并不是分布式系统的内部服务，例如它是客户端，
难以让C为整个系统做通信。

因此，我们最多可以让其中的一个分区，向外提供服务。那么应该如何选择唯一的分区（**正确分区**）呢？
当客户端与并不是系统限定的分区（**错误分区**）进行通信时，这些分区又该如何处理请求呢（即如何感知到自己并不是正确分区）？

因为分区之间不能通信，所以，我们寻找的是各个分区不需要通信就已经知道的共同的知识。这是什么？

首先，每个分区都知道开始时的集群总节点数量5，每个分区都知道自己分区内部的情况，如节点数量2，每个分区都不知道其他分区的情况。

聪明的你已经知道了，那就是 **多数派**，多数派是指这个分区的节点数量超过总节点数的一半，每个分区都知道自己是不是多数派，且多数派只有一个。

所以，当客户端请求多数派分区时，多数派分区可以提供服务，而少数派分区接收到请求应该拒绝，当网络恢复时，少数派分区与多数派同步完成后，整体可以恢复。

然而，网络分区可以会发生在任意时刻，所以在上述的从更新到可读的过程中，节点需要确保自己所处在多数派中，即节点需要知道多数派节点都更新了，节点才能进入可读状态。
在客户端请求一致性读的时候，多数派分区可能已经发生了变更。比如之前写入节点是1、2、3，但现在多数派变成了2、3、4。即现在的多数派分区中，可能存在旧数据。
但是，时间轴上的每个多数派都会存在最新的数据。所以，对客户端来说，只要在多数节点上读取值，然后比较一下version（每次写入的时候记录version），就能获取到最新值。

总结一下，简单来说就是，两阶段+多数派写+多数派读。

### paxos与raft


### redis、zookeeper、etcd

### 分布式事务与分布式共识
