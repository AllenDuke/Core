# 当我们在谈论分布式的时候，我们到底在谈论些什么
## 什么是分布式
分布式可以这样理解，就是一种操作，需要经过一系列计算机才能完成。而这些计算机是通过网络进行通信的，而网络则是具有一定延迟的，甚至是不可信的。

而为什么需要多台计算机呢？自然是单台计算的资源并不能完成“计算”（广义）。纵深发展的单体大型机当然也能解决问题，但是不足够“弹性”，例如，一些秒杀活动等
需要动态扩张/减少资源的，大型机难以满足“刚刚好”，少了不足，多了浪费。

所以，换个思路横向拓展，通过多个小型机和网络来完成计算，小型机则可以极大地接近“刚刚好”，减少浪费。当然这也带来了额外的性能和出错风险。
比如网络通信的速度越不如本地通信的速度，同时小型机组成的网络中，任一节点出错都可能导致计算失败，而随着节点数量的增加，这种出错的风险越大。

因此，正是在这样的背景下，我们需要一系列的算法和工程实现来构建一个可靠、可用的分布式系统，使得这些节点正确地完成计算。

## 分布式理论
那么分布式系统，面临或者说需要解决哪些问题呢？一般来说，相对于单体架构，分布式的问题可以认为主要是网络（可信情况下）带来的延迟。
如A->B，A往B发送消息后，等待B的响应。消息在网络中传输需要一定的时间，也可能丢失（TCP不会），消息到达B后，B开始处理，而在B处理过程中，
B可能会发生宕机，导致B难以在可见时间限度内响应A。
对于A来说，A并不知道消息是否到达了B或者B对消息的处理情况，除非A收到了B的响应。
但正如上面所述，A可能永远也得不到响应。那么，在A得到响应之前， AB所组成的系统，该如何演进？

如果AB是一个无状态的系统，比如对外提供的只是一些计算服务（如加法，乘法），那么就直接让客户端等待或者返回超时就好了。
但是，如果AB是一个有状态的系统，如AB是一个存储系统，我们需要仔细考虑好A，B，AB整体的状态演进，否则很容易就会导致数据不一致，客户端拿到不一致
的数据，可能会引发更大的灾难。

以下将默认AB为有状态的分布式存储系统（主备，集群）。
### CAP问题
C：一致性，A：可用性，P：分区容错性。

在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操
作将无法同步到另外一个节点，所以数据的「一致性」将无法满足，因为两个分布式节点的
数据不再保持一致。除非我们牺牲「可用性」，也就是暂停分布式节点服务，在网络分区发
生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。

对于一些要求性能而不要求强一致的，可以用AP，比如，微博，qps高，要求响应快速，使用旧版本提供服务也没什么大影响，这样可以用AP类型的redis做缓存。

AP容易做到的，读即快照读，数据同步保证最终一致性。

现在我们来看看如何实现C(强一致/线性一致)P。
## 一致性
### 顺序一致
### 线性一致
明显地，如果数据只有一份，那就是单机了（参加redis的集群模式，或者其他分片路由存储系统）。但为了避免单点故障，一般都会要求数据有多个备份。
在这种情况下，每个节点都需要进行数据更新操作，如果这些操作不在同一个同步区域内进行，那么节点的状态就肯定无法同时达到一致。

所以，一种方式是创建一个同步区域（分布式事务，线性一致的两阶段提交事务参见：https://github.com/AllenDuke/simple-kv-strong-consistency）。
事务开始：
- A加锁（线性一致读时不可读）（mysql中当前读时不可读）
- A更新
- B加锁（加锁失败或死锁则回滚，当然在知道锁的范围时，可以提前在各节点先加锁）
- B更新
- A提交
- B提交
- A解锁
- B解锁
事务结束。

也就是来说，开始->A更新且通知B更新->B更新且回复A->A可读且通知B可读--x-->B可读->结束。
在x阶段，B接收到客户端的读请求时，客户端等待，或者B主动向A询问是否可读（此时A知道B已更新，A如果已经更新，则A标记自己可读，且回复B可读）。

用博弈论来看，当”更新“成为AB的二阶知识，即AB相互知道对方已经更新，则AB可以进入一致性可读状态。

### 冲突与共识
在上述的例子中，会有个加锁的环节，因为每个节点都可以接收写请求，有时会有冲突，如针对同一个key进行更新。那该如何加解锁呢？
一个简单的方法时，引入一个单体的锁服务，那这样也就引入了单点故障，一般不可取。
所以，锁是加在本地的，通过请求来对其他节点进行加锁。当所有节点都加锁成功，则可以进行事务。

分布式事务是可以实现一致性，但不能满足P。那么现在假设有5个字节，划分成两个分区，节点数量分别是2和3。
