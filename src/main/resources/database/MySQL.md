# MySQL
## 数据库四大范式
第一范式：为表格。

第二范式：第一范式基础上，消除对主键的部分依赖。

第三范式：第二范式基础上，消除对主键的传递依赖。

BC范式：第一范式基础上，消除对候选键的部分依赖和传递依赖。（与第三范式相比，要求从主键扩大为候选键）

反范式：通过增加冗余字段来减少表的连接，提高读效率。
## 数据库存储原理
索引的数据结构为B+树（支持范围查找），Hash索引（不支持范围查找）
## MyIsam
1. MyIsam中的索引与数据是分开的，索引中的节点记录的是数据在磁盘中的位置。
2. 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁.
3. 不支持事务。
4. 不支持外键。
5. 不支持崩溃后的安全恢复。
6. 支持延迟更新索引，极大提升写入性能。
7. 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用。
### B+树
索引树

![ismb+tree](../images/ismb+tree.PNG)
## Innodb
Innodb的主键B+树中的叶子节点既是索引也是数据（双向链表），它是以主键为聚集索引，表中数据的物理顺序与主键索引的逻辑顺序相同。
因此它要求数据必定有主键（当不设定主键时，mysql会创建一个默认的主键）。 

对于其他非主键索引树，叶子节点上的数据为主键号（一致性和节省空间）。

叶子节点之间由双向链表连接，作用：
1. 使用自增数据时可以直接从插入到链表末尾，而uuid就不行了。
2. 实现范围查找，而B树只能中序遍历查找。

一个B+树的叶子节点为一页，页默认大小为16kb，而一行数据最大为64kb，意味着要记录行溢出，该行溢出到另一页。
假设一行数据为1kb，那么一页可以容纳16条数据。默认为16kb是因为文件系统一次IO读取一般4kb（视具体情况而定），而根据局部性原理，
它附近的数据马上会读取到，故设为16kb。那么读取一个节点就发生一次IO。

一棵B+树，32位机阶数为512，64位机阶数位171，一般高度为3。

一棵b+树一般能存2000万左右的记录。一个节点占一页16kb，假设主键为bigint（8b+6b指针）14b，
那么一个非叶子节点可以有16kb/14b=1170个，假设树高为3，那么，叶子节点数1170*1170，假设一行记录大小为1kb，
那么一个叶子节点可以有16kb/1kb=16条，总记录数：1170*1170*16=2000万左右。
### B+树
主键索引树

![b+tree](../images/b+tree.PNG)
### 联合索引，最左前缀法则
![composite-index](../images/compostie-index.png)

这里为联合主键，联合索引也一个道理，只不过data换成主键。
联合索引中，叶子节点中索引依次排放，插入是依次比较，每个节点内元素成字典序，所以才有最左前缀原理，中间若失配，索引将无效。
### 索引覆盖 回表
索引覆盖：当这颗非主键索引树已经能满足要查询的数据时，那么就不用回表，否则就要根据拿到的主键id，去主键索引树上查到数据（回表）。
### 事务
mysql默认事务自动提交（一条语句一个事务），可以手动设置事务是否自动提交。

事务的隔离矩阵

![islationMatrix](../images/islationMatrix.PNG)

mysql默认的事务隔离级别为RR（Repeatable Read 可重复读），解决幻读的方案如下：
1. 利用MVCC解决快照读的幻读问题。select * from t where a=1;属于快照读
2. 利用next-key解决当前读的幻读问题。select * from t where a=1 lock in share mode;属于当前读 
select * from t where a=1 for upda;属于当前读
### 幻读的理解
在隔离级别为可重复读的条件下，幻读表现为：
事务A往表里插入了一条id为5的记录，事务B没有读到，但事务B在也要往表里插入id为5的记录的时候，却被告知，5已经存在，插入失败，
就像是自己已经读到5了一样。
### MVCC
InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。
这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，
事务开始时刻的系统版本号会作为事务的ID.

总的来说， 当前事务不读取后来事务新增或修改的数据（读取之前的），不理会是否被后来事务删除（被后来的事务删除了照样读取）。
### 事务与锁
事务在执行到要加锁的语句时开始加锁，commit后释放锁。此时遵循两段锁协议：
1. 加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X
锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。
2. 解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。
#### 锁的兼容矩阵
![locktype](../images/locktype.png)
#### 行锁
1. Record lock ：对索引项加锁，即锁定一条记录。
2. Gap lock：对索引项之间的‘间隙’、对第一条记录前的间隙或最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身
3. Next-key Lock：锁定一个范围的记录并包含记录本身（上面两者的结合）。
![next-key](../images/next-key.png)
#### 意向表锁的理解
如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，
那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，
当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），
在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。
### 日志
#### undo log
![undo-log](../images/undo-log.png)
![mvcc](../images/mvcc.png)
#### redo log
![redo-log](../images/redo-log.png)
#### bin log
主从复制的基础：binlog日志和relaylog日志
##### 什么是MySQL主从复制
简单来说就是保证主SQL（Master）和从SQL（Slave）的数据是一致性的，向Master插入数据后，
Slave会自动从Master把修改的数据同步过来（有一定的延迟），通过这种方式来保证数据的一致性，就是主从复制
##### 复制方式
MySQL5.6开始主从复制有两种方式：基于日志（binlog）、基于GTID（全局事务标示符）。 本文只涉及基于日志binlog的主从配置

##### 复制原理
1. Master将数据改变记录到二进制日志(binary log)中，也就是配置文件log-bin指定的文件，这些记录叫做二进制日志事件(binary
 log events) 
2. Slave通过I/O线程读取Master中的binary log events并写入到它的中继日志(relay log)
3. Slave重做中继日志中的事件，把中继日志中的事件信息一条一条的在本地执行一次，完成数据在本地的存储，
从而实现将改变反映到它自己的数据(数据重放)

##### 什么是binlog
1. binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息，例如更改数据库表和更改内容的SQL语句都会记录到binlog里，
但是对库表等内容的查询不会记录。
   * 默认情况下，binlog日志是二进制格式的，不能使用查看文本工具的命令（比如，cat，vi等）查看，而使用mysqlbinlog解析查看。
2. binlog的作用 当有数据写入到数据库时，还会同时把更新的SQL语句写入到对应的binlog文件里，这个文件就是上文说的binlog文件。
使用mysqldump备份时，只是对一段时间的数据进行全备，但是如果备份后突然发现数据库服务器故障，这个时候就要用到binlog的日志了。
   * 主要作用是用于数据库的主从复制及数据的增量恢复。
3. 如何开启binlog日志功能 在mysql的配置文件my.cnf中，增加log_bin参数即可开启binlog日志，也可以通过赋值来指定binlog日志的文件名，
实例如下：
   * [root@DB02 ~]# grep log_bin /etc/my.cnf log_bin = /application/mysql/logs/dadong-bin
   * [root@DB02 ~]# 提示：也可以按“log_bin = /application/mysql/logs/dadong-bin”命名，目录要存在。
   为什么要刷新binlog?找到全备数据和binlog文件的恢复临界点.
### checkpoint
checkpoint是为了定期将db buffer的内容刷新到data file。当遇到内存不足、db buffer已满等情况时，
需要将db buffer中的内容/部分内容（特别是脏数据）转储到data file中。在转储时，会记录checkpoint发生的”时刻“。
在故障回复时候，只需要redo/undo最近的一次checkpoint之后的操作。
### sql语句
#### sql优化
- 字段
  * 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
  * VARCHAR的长度只分配真正需要的空间
  * 使用枚举或整数代替字符串类型
  * 尽量使用TIMESTAMP而非DATETIME
  * 单表不要有太多字段，建议在20以内
  * 避免使用NULL字段，很难查询优化且占用额外索引空间
  * 用整型来存IP
- 索引
  * 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，
  可根据EXPLAIN来查看是否用了索引还是全表扫描
  * 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描
  * 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段
  * 字符字段只建前缀索引
  * 字符字段最好不要做主键
  * 不用外键，由程序保证约束
  * 尽量不用UNIQUE，由程序保证约束
  * 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引
- 查询SQL
  * 可通过开启慢查询日志来找出较慢的SQL
  * 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，
  查询时要尽可能将操作移至等号右边
  * sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
  * 不用SELECT *
  * OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
  * 不用函数和触发器，在应用程序实现
  * 避免%xxx式查询
  * 少用JOIN
  * 使用同类型进行比较，比如用'123'和'123'比，123和123比
  * 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
  * 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
  * 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大，分页时可利用上索引，如：
  SELECT * from user limit 100001,20; -> SELECT * from user where id >=100001 limit 20;
#### where与having
1. WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。(聚合前)
2. GROUP BY 子句用来分组 WHERE 子句的输出。
3. HAVING 子句用来从分组的结果中筛选行。（聚合后）
#### 索引中的null值
在mysql中，null作为一种特殊的值也依然是可以用到索引的，只不过对比平常的值，null的运算只有is null和is not null，不能用>,<,=, 
对其进行算术运算的结果依然为null。