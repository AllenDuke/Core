# redis
Remote dictionary Service 远程字典服务
## 集群
如何理解redis的集群？首先，单机的redis有压力和单点故障的问题。
要解决压力，可以做主从架构，主写从读，于是有了主从数据库的一致性问题（MySQL也一样）。为了解决一致性，这里介绍全量复制。
1. 从发送psyn命令。
2. 主收到命令后，执行bgsave，创建一个子进程，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）
记录从现在开始执行的所有写命令。
3. 从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。
4. 主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。
5. 如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。

至此，又引入了新的问题，那就是主宕机后需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，
还会造成一段时间内服务不可用。于是有了哨兵模式，主宕机后，由哨兵来把从升级为主。

哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。
当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。
故障切换（failover）的过程。假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，
仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，
那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，
让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。

继续增进，现在希望写的压力也分散，而且因为内存有上限，希望把一部分数据分到其他的机器上，而不是每台机器都保存完成的数据镜像。
于是有了cluster模式。
一组Redis Cluster是由多个Redis实例组成，官方推荐我们使用6实例，其中3个为主节点，3个为从结点。一旦有主节点发生故障的时候，
Redis Cluster可以选举出对应的从结点成为新的主节点，继续对外服务，从而保证服务的高可用性。
Redis Cluster 把所有的数据划分为16384个不同的槽位，可以根据机器的性能把不同的槽位分配给不同的Redis实例，对于Redis实例来说，
他们只会存储部门的Redis数据，当然，槽的数据是可以迁移的，不同的实例之间，可以通过一定的协议，进行数据迁移。
   * 数据获取：首先客户端需要保存一份Redis Cluster槽相关的信息，也就是路由表，然后对即将访问的key进行哈希计算，
   计算出对应的槽位，然后向对应的Redis实例发起查询请求。如果访问的Redis实例中，的确保存着对应槽的数据信息，就会进行返回，
   否则向客户端返回一个Moved指令，让客户端到正确的地址进行获取。
   * 数据迁移：在分布式系统中，衡量一个系统好坏的一项重要指标，系统的扩展性。什么是系统的扩展性呢？就是今天你又10万个用户，
   需要4台机器进行服务，如果明天的用户数量增加到20万了，是不是只要简单的增加4台机器就行，同时又不需要进行复杂的数据迁移。
   Redis Cluster便是如此，当你新增一些实例的时候，只需要将一部分槽位迁移到新的实例即可。在迁移的过程中，
   客户端会先去旧的实例上去查询数据，因为迁移正在发生，如果对应的数据还在本机上，那么直接返回，
   否则返回让客户端重定向到新的实例。客户端先向新的机器发起ask指令，新实例返回成功后，再一次查询最终的结果。
## 线程模型
![redis-reactor](../images/redis-reactor.PNG)

单线程是指：
1. 网络io是单线程的，该线程把命令放到队列里。
2. 事件的处理是单线程的，该线程去消费队列。

io线程中的epoll_wait采用的非阻塞的调用，因为还要去处理别的事情，而nginx的io线程就负责accept，所以采用阻塞式调用，
而netty中采用超时select，因为要处理定时任务如心跳。
## 分布式锁
### 单实例下（一主多从）
获取锁（设置锁）
```java
SET key_name my_random_value NX PX 30000                  
// NX 表示if not exist 就设置并返回True，否则不设置并返回False   PX 表示过期时间用毫秒级， 30000 表示这些毫秒时间后此key过期
```
释放锁（删除锁） 最好使用Lua脚本删除（redis保证执行此脚本时不执行其他操作，保证操作的原子性），代码如下；逻辑是先获取key，
如果存在并且值是自己设置的就删除此key;否则就跳过；
```java
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
流程图：

![redis-lock](../images/redis-lock.PNG)
### Redission 常用于单实例下
redisson很好了封装了上面这把锁，使其适用于多种复杂的情况，如可重入，过期等等。
流程：

![redission](../images/redission.PNG)

redission的核心为：每隔一段时间若client仍持有锁为其续命、延长超时时间。
### 多实例下（Cluster模式下） RedLock

